combinedIG <- igraph::union(edgepmatAllIG,stringIG)
edgepmat <- as.matrix(as_adjacency_matrix(combinedIG))
# check whether sorting is correct
colnames(edgepmat)==colnames(mutCovData)
edgepmat
edgepmat2 <- 2-edgepmat
edgepmat2
# check whether sorting is correct
colnames(edgepmat2)==colnames(mutCovData)
# save edgepmat
write.table(edgepmat2, "data/string-edgepmat.txt")
setwd("~/Documents/phd_main/packages/netClust")
setwd("~/Documents/phd_main/packages/netClust")
# Simulate binary data
ss <- c(400,500,600) # samples in each cluster
myData <- sampleData(kclust = 3, Nvars = 20, sseed = 2, samplesizes = ss)
library(netClust)
# Simulate binary data
ss <- c(400,500,600) # samples in each cluster
myData <- sampleData(kclust = 3, Nvars = 20, sseed = 2, samplesizes = ss)
library(netClust)
library(netClust)
library("devtools")
install_github("fritzbayer/netClust", auth_token="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")
library(netClust)
library(netClust)
# Simulate binary data
ss <- c(400,500,600) # samples in each cluster
myData <- sampleData(kclust = 3, Nvars = 20, sseed = 2, samplesizes = ss)
netClust::bestAICsearch
#' @import ggplot2
#' @importFrom reshape2 melt
#' @importFrom grDevices rgb
#'
bestAICsearch <- function(binaryMatrix, minK = 2, maxK, chiVec, startseed = 100, nIterations = 50,AICrange=100) {
#
#     require('ggplot2')
#     require('reshape2')
### Check input parameters
if(missing(maxK)) stop("Need to input maximum number of clusters k.")
if(missing(chiVec)) stop("Need to input a range of chi values.")
if (!identical(maxK - floor(maxK), 0) || maxK < 2) stop("maxK has to be a positive whole number > 1.")
if (!identical(minK - floor(minK), 0) || minK < 1) stop("minK has to be a positive whole number > 1.")
if(any(chiVec<0)) stop("Chi needs to be positive.")
### Prepare matrix for plotting
nrow <- maxK - minK + 1
ncol <- length(chiVec)
aics<-matrix(NA,nrow=nrow,ncol=ncol)
output <- list()
### Populate matrix wich AICs
for(jj in 1:ncol){
chi<- chiVec[jj]
print(paste("Currently clustering for chi =", chi))
if(chi==0){
chi<-1e-3 # replace 0 by 1e-3 to avoid taking log of 0
}
for(kk in minK:maxK){
bestCluster <- BBMMclusterEM(binaryMatrix = binaryMatrix,
chi = chi, kclust = kk,
startseed = startseed,
nIterations = nIterations)
if(length(table(bestCluster$newclustermembership))==kk){
aics[kk - minK + 1,jj]<-bestCluster$testAIC
output[[kk - minK + 1 + (jj - 1)*(maxK-minK+1)]] <- bestCluster
}
}
}
ks<-rep(0,ncol)
minaics<-rep(0,ncol)
minaics <- apply(aics, 2, min, na.rm=TRUE)
aics<-t(aics)
aics<-aics - minaics
topaics<-AICrange
aics[which(aics>topaics)]<-topaics
aicsscaled<-t(t(aics)/colSums(aics))
#heatmap(t(aics),Rowv=NA, Colv=NA,col = rainbow(256))
divergy<-aics
#divergy[which(is.na(divergy))]<-maxxy
rownames(divergy)<-chiVec
colnames(divergy)<-c(minK:maxK)
meltdivergy<-melt(divergy)
#ggplot(data = meltdivergy, aes(x=Var1, y=Var2, fill=value)) +
#    geom_tile()
#middycol<-c(0.8,0.2,0)
# ggheatmap<-ggplot(data = meltdivergy, aes(Var1, Var2, fill = value))+
ggheatmap<-ggplot(data = meltdivergy)+
geom_tile() +
xlab(expression(chi)) +
ylab("k") +
scale_fill_gradient2(high =rgb(0.98,0.98,1), low = rgb(0,0.35,0.8),
mid=rgb(0.49,0.665,0.9),space="Lab",na.value="grey75",
midpoint=topaics/2,limit = c(0,topaics), name="AIC\nchange\n") +
scale_y_continuous(breaks=c(minK:maxK)) +
theme_minimal() +
theme(axis.title.x = element_text(vjust=-1),axis.title.y = element_text(angle=0,hjust=-0.5,vjust=0.505)) +
theme(axis.text.x = element_text(angle = 0, vjust = 0.5,size = 20, hjust = 0.6),
axis.text.y = element_text(angle = 0, vjust = 0.5,size = 20, hjust = 1),
legend.text=element_text(size=20),
axis.title=element_text(size=30),
legend.title=element_text(size=24))+theme(legend.key.size = unit(2,"line")) +
theme(plot.margin=unit(c(-0.3,-0.3,0.4,0.4),"cm"))
print(ggheatmap)
#pdf(paste("heatmapaic.pdf",sep=""), width=7.5, height=6, onefile=F, pointsize=10,  paper="special")
ggheatmap +
theme(
#axis.title.x = element_text("prune and reattach probability"),
#axis.title.y = element_text("swap two nodes probability"),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank())
#dev.off()
return(output)
}
aa <- bestAICsearch(myData, minK = 2, 5, 1, startseed = 100, nIterations = 50,AICrange=100)
devtools::load_all()
aa <- bestAICsearch(myData, minK = 2, 5, 1, startseed = 100, nIterations = 50,AICrange=100)
traceback()
#' @import ggplot2
#' @importFrom reshape2 melt
#' @importFrom grDevices rgb
#'
bestAICsearch <- function(binaryMatrix, minK = 2, maxK, chiVec, startseed = 100, nIterations = 50,AICrange=100) {
#
#     require('ggplot2')
#     require('reshape2')
### Check input parameters
if(missing(maxK)) stop("Need to input maximum number of clusters k.")
if(missing(chiVec)) stop("Need to input a range of chi values.")
if (!identical(maxK - floor(maxK), 0) || maxK < 2) stop("maxK has to be a positive whole number > 1.")
if (!identical(minK - floor(minK), 0) || minK < 1) stop("minK has to be a positive whole number > 1.")
if(any(chiVec<0)) stop("Chi needs to be positive.")
### Prepare matrix for plotting
nrow <- maxK - minK + 1
ncol <- length(chiVec)
aics<-matrix(NA,nrow=nrow,ncol=ncol)
output <- list()
### Populate matrix wich AICs
for(jj in 1:ncol){
chi<- chiVec[jj]
print(paste("Currently clustering for chi =", chi))
if(chi==0){
chi<-1e-3 # replace 0 by 1e-3 to avoid taking log of 0
}
for(kk in minK:maxK){
bestCluster <- BBMMclusterEM(binaryMatrix = binaryMatrix,
chi = chi, kclust = kk,
startseed = startseed,
nIterations = nIterations)
if(length(table(bestCluster$newclustermembership))==kk){
aics[kk - minK + 1,jj]<-bestCluster$testAIC
output[[kk - minK + 1 + (jj - 1)*(maxK-minK+1)]] <- bestCluster
}
}
}
ks<-rep(0,ncol)
minaics<-rep(0,ncol)
minaics <- apply(aics, 2, min, na.rm=TRUE)
aics<-t(aics)
aics<-aics - minaics
topaics<-AICrange
aics[which(aics>topaics)]<-topaics
aicsscaled<-t(t(aics)/colSums(aics))
#heatmap(t(aics),Rowv=NA, Colv=NA,col = rainbow(256))
divergy<-aics
#divergy[which(is.na(divergy))]<-maxxy
rownames(divergy)<-chiVec
colnames(divergy)<-c(minK:maxK)
meltdivergy<-melt(divergy)
#ggplot(data = meltdivergy, aes(x=Var1, y=Var2, fill=value)) +
#    geom_tile()
#middycol<-c(0.8,0.2,0)
ggheatmap<-ggplot(data = meltdivergy, aes(Var1, Var2, fill = value))+
# ggheatmap<-ggplot(data = meltdivergy)+
geom_tile() +
xlab(expression(chi)) +
ylab("k") +
scale_fill_gradient2(high =rgb(0.98,0.98,1), low = rgb(0,0.35,0.8),
mid=rgb(0.49,0.665,0.9),space="Lab",na.value="grey75",
midpoint=topaics/2,limit = c(0,topaics), name="AIC\nchange\n") +
scale_y_continuous(breaks=c(minK:maxK)) +
theme_minimal() +
theme(axis.title.x = element_text(vjust=-1),axis.title.y = element_text(angle=0,hjust=-0.5,vjust=0.505)) +
theme(axis.text.x = element_text(angle = 0, vjust = 0.5,size = 20, hjust = 0.6),
axis.text.y = element_text(angle = 0, vjust = 0.5,size = 20, hjust = 1),
legend.text=element_text(size=20),
axis.title=element_text(size=30),
legend.title=element_text(size=24))+theme(legend.key.size = unit(2,"line")) +
theme(plot.margin=unit(c(-0.3,-0.3,0.4,0.4),"cm"))
print(ggheatmap)
#pdf(paste("heatmapaic.pdf",sep=""), width=7.5, height=6, onefile=F, pointsize=10,  paper="special")
ggheatmap +
theme(
#axis.title.x = element_text("prune and reattach probability"),
#axis.title.y = element_text("swap two nodes probability"),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank())
#dev.off()
return(output)
}
aa <- bestAICsearch(myData, minK = 2, 5, 1, startseed = 100, nIterations = 50,AICrange=100)
aa
aa[[1]]$testAIC
aa[[2]]$testAIC
aa[[3]]$testAIC
aa[[4]]$testAIC
aa[[5]]$testAIC
aa <- bestAICsearch(myData, minK = 2, 7, 1, startseed = 100, nIterations = 50,AICrange=100)
aa[[1]]$testAIC
aa[[2]]$testAIC
aa[[3]]$testAIC
aa[[4]]$testAIC
aa[[5]]$testAIC
aa[[6]]$testAIC
aa[[7]]$testAIC
ggheatmap<-ggplot(data = meltdivergy, aes(Var1, Var2, fill = value))+
# ggheatmap<-ggplot(data = meltdivergy)+
geom_tile() +
xlab(expression(chi)) +
ylab("k") +
scale_fill_gradient2(high =rgb(0.98,0.98,1), low = rgb(0,0.35,0.8),
mid=rgb(0.49,0.665,0.9),space="Lab",na.value="grey75",
midpoint=topaics/2,limit = c(0,topaics), name="AIC\nchange\n") +
scale_y_continuous(breaks=c(minK:maxK)) +
theme_minimal() +
theme(axis.title.x = element_text(vjust=-1),axis.title.y = element_text(angle=0,hjust=-0.5,vjust=0.505)) +
theme(axis.text.x = element_text(angle = 0, vjust = 0.5,size = 20, hjust = 0.6),
axis.text.y = element_text(angle = 0, vjust = 0.5,size = 20, hjust = 1),
legend.text=element_text(size=20),
axis.title=element_text(size=30),
legend.title=element_text(size=24))+theme(legend.key.size = unit(2,"line")) +
theme(plot.margin=unit(c(-0.3,-0.3,0.4,0.4),"cm"))
data.frame(c(1:3))
a <- data.frame(c(1:3))
#' @import ggplot2
#' @importFrom reshape2 melt
#' @importFrom grDevices rgb
#'
bestAICsearch <- function(binaryMatrix, minK = 2, maxK, chiVec, startseed = 100, nIterations = 50,AICrange=100) {
#
#     require('ggplot2')
#     require('reshape2')
### Check input parameters
if(missing(maxK)) stop("Need to input maximum number of clusters k.")
if(missing(chiVec)) stop("Need to input a range of chi values.")
if (!identical(maxK - floor(maxK), 0) || maxK < 2) stop("maxK has to be a positive whole number > 1.")
if (!identical(minK - floor(minK), 0) || minK < 1) stop("minK has to be a positive whole number > 1.")
if(any(chiVec<0)) stop("Chi needs to be positive.")
### Prepare matrix for plotting
nrow <- maxK - minK + 1
ncol <- length(chiVec)
aics<-matrix(NA,nrow=nrow,ncol=ncol)
output <- list()
### Populate matrix wich AICs
for(jj in 1:ncol){
chi<- chiVec[jj]
print(paste("Currently clustering for chi =", chi))
if(chi==0){
chi<-1e-3 # replace 0 by 1e-3 to avoid taking log of 0
}
for(kk in minK:maxK){
bestCluster <- BBMMclusterEM(binaryMatrix = binaryMatrix,
chi = chi, kclust = kk,
startseed = startseed,
nIterations = nIterations)
if(length(table(bestCluster$newclustermembership))==kk){
aics[kk - minK + 1,jj]<-bestCluster$testAIC
output[[kk - minK + 1 + (jj - 1)*(maxK-minK+1)]] <- bestCluster
}
}
}
ks<-rep(0,ncol)
minaics<-rep(0,ncol)
minaics <- apply(aics, 2, min, na.rm=TRUE)
aics<-t(aics)
aics<-aics - minaics
topaics<-AICrange
aics[which(aics>topaics)]<-topaics
aicsscaled<-t(t(aics)/colSums(aics))
#heatmap(t(aics),Rowv=NA, Colv=NA,col = rainbow(256))
divergy<-aics
#divergy[which(is.na(divergy))]<-maxxy
rownames(divergy)<-chiVec
colnames(divergy)<-c(minK:maxK)
meltdivergy<-melt(divergy)
#ggplot(data = meltdivergy, aes(x=Var1, y=Var2, fill=value)) +
#    geom_tile()
#middycol<-c(0.8,0.2,0)
ggheatmap<-ggplot(data = meltdivergy, aes(meltdivergy$Var1, meltdivergy$Var2, fill = meltdivergy$value))+
# ggheatmap<-ggplot(data = meltdivergy)+
geom_tile() +
xlab(expression(chi)) +
ylab("k") +
scale_fill_gradient2(high =rgb(0.98,0.98,1), low = rgb(0,0.35,0.8),
mid=rgb(0.49,0.665,0.9),space="Lab",na.value="grey75",
midpoint=topaics/2,limit = c(0,topaics), name="AIC\nchange\n") +
scale_y_continuous(breaks=c(minK:maxK)) +
theme_minimal() +
theme(axis.title.x = element_text(vjust=-1),axis.title.y = element_text(angle=0,hjust=-0.5,vjust=0.505)) +
theme(axis.text.x = element_text(angle = 0, vjust = 0.5,size = 20, hjust = 0.6),
axis.text.y = element_text(angle = 0, vjust = 0.5,size = 20, hjust = 1),
legend.text=element_text(size=20),
axis.title=element_text(size=30),
legend.title=element_text(size=24))+theme(legend.key.size = unit(2,"line")) +
theme(plot.margin=unit(c(-0.3,-0.3,0.4,0.4),"cm"))
print(ggheatmap)
#pdf(paste("heatmapaic.pdf",sep=""), width=7.5, height=6, onefile=F, pointsize=10,  paper="special")
ggheatmap +
theme(
#axis.title.x = element_text("prune and reattach probability"),
#axis.title.y = element_text("swap two nodes probability"),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank())
#dev.off()
return(output)
}
aa <- bestAICsearch(myData, minK = 2, 3, 1, startseed = 100, nIterations = 50,AICrange=100)
setwd("~/Documents/phd_main/projects/network-based-clustering/pancancer-clustering-master/code")
# Prepare session, load packages
rm(list=ls())
library(survival)
library(RColorBrewer)
output <- read.table("../data/tcga-clinical-information.txt", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
cluster.membership <- read.table("../data/annotation-matrix.txt", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
cluster.membership <- cluster.membership[,c(1:4)] # select columns
#rename some columns
colnames(cluster.membership)[colnames(cluster.membership)=="type"] <- "tissue"
colnames(cluster.membership)[colnames(cluster.membership)=="cluster"] <- "group"
# Change group from 1:22 to A:V
cluster.membership$group <- as.factor(cluster.membership$group)
levels(cluster.membership$group) <- LETTERS[1:length(unique(cluster.membership$group))]
# Merge clinical data with clustering
clinical <- merge(output,cluster.membership, by="id", sort=FALSE)
table(clinical$group)
clinical[,c('age','event','time')] <- lapply(clinical[,c('age','event','time')], as.numeric)
# Remove subtype from tissue
clinical[,c('stage','group','tissue')] <- lapply(clinical[,c('stage','group','tissue')], factor)
# Clinical only
stageTest <- summary(coxph(Surv(time, event) ~ stage, data = clinical, na.action = "na.omit"))$logtest[1]
ageTest <- summary(coxph(Surv(time, event) ~ stage + age, data = clinical, na.action = "na.omit"))$logtest[1]
# Clinical + tissue
tissueTest <- summary(coxph(Surv(time, as.numeric(event)) ~ stage + age + tissue, data = clinical, na.action = "na.omit"))$logtest[1]
# Clinical + tissue + group
groupTest <- summary(coxph(Surv(time, as.numeric(event)) ~ stage + age + tissue + group, data = clinical, na.action = "na.omit"))$logtest[1]
LR <- round((groupTest-tissueTest)/2, 1)
pvalue <- round(pchisq(q = groupTest-tissueTest, df = length(levels(clinical$group)) - 1, lower.tail = FALSE), 10)
paste(round(LR, 1), "&", pvalue, sep = " ")
clusterTest <- summary(coxph(Surv(time, event) ~ group, data = clinical, na.action = "na.omit"))$logtest[1]
LR <- clusterTest/2
pvalue <- pchisq(q = clusterTest, df = length(levels(clinical$group)) - 1, lower.tail = FALSE)
paste(round(LR, 1), "&", pvalue, sep = " ")
# Prepare session, load packages
rm(list=ls())
library(survival)
library(RColorBrewer)
output <- read.table("../data/tcga-clinical-information.txt", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
# Load classification by mutation profile (cluster assignment)
cluster.membership <- read.table("../data/annotation-matrix.txt", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
cluster.membership <- cluster.membership[,c(1:4)] # select columns
#rename some columns
colnames(cluster.membership)[colnames(cluster.membership)=="type"] <- "tissue"
colnames(cluster.membership)[colnames(cluster.membership)=="cluster"] <- "group"
# Change group from 1:22 to A:V
cluster.membership$group <- as.factor(cluster.membership$group)
levels(cluster.membership$group) <- LETTERS[1:length(unique(cluster.membership$group))]
# Merge clinical data with clustering
clinical <- merge(output,cluster.membership, by="id", sort=FALSE)
table(clinical$group)
clinical[,c('age','event','time')] <- lapply(clinical[,c('age','event','time')], as.numeric)
# Remove subtype from tissue
clinical[,c('stage','group','tissue')] <- lapply(clinical[,c('stage','group','tissue')], factor)
# Kaplan-Meier curve for 22 groups
# Colors A -- V
colourysdots<-c("#202020","#771122","#AA4455","#DD7788","#774411","#AA7744",
"#DDAA77","#777711","#AAAA44","#DDDD77","#117744","#44AA77",
"#88CCAA","#117777","#44AAAA","#77CCCC","#114477","#4477AA",
"#77AADD","#771155","#AA4488","#CC99BB")
pdf('./overall-survival-cluster-types-22.pdf', width=10, height=10)
par(mar = c(4.5,4.5,0.5,0.5))
plot(survfit(Surv(time = as.numeric(time)/365, event = as.numeric(event)) ~ group, data = clinical), col=colourysdots, ylab='Survival probability', xlab='Survival (years)', cex.lab=1.75, cex.axis=1.5, mark.time = T, xlim=c(0,24))
pdf('./overall-survival-cluster-types-22.pdf', width=10, height=10)
par(mar = c(4.5,4.5,0.5,0.5))
plot(survfit(Surv(time = as.numeric(time)/365, event = as.numeric(event)) ~ group, data = clinical), col=colourysdots, ylab='Survival probability', xlab='Survival (years)', cex.lab=1.75, cex.axis=1.5, mark.time = T, xlim=c(0,24))
legend(x = 19, y = 1.01, legend = paste(levels(clinical$group), sep=' '), pch = 15, col=colourysdots, cex=1.75, ncol = 2,title="Cluster", bg='white')
xs<-c(15,5.6,10,15,9.2,11.5,15.2,18.5,11.5,10.9,8.9,9.3,9.6,13.7,14.4,16.5,15,12.6,11.1,20.8,22.5,21.5)
ys<-c(0.86,0.27,0.34,0.645,0.385,0.445,0.115,0.125,0.505,0.03,0.425,0.2,0.545,0.1,0.28,0.17,0.4,0.03,0.32,0.28,0.125,0.41)
for(ii in 1:length(xs)){
text(xs[ii],ys[ii],col=colourysdots[ii],LETTERS[ii],cex=1.5)
}
dev.off()
# Prepare session, load packages
rm(list=ls())
library(survival)
library(RColorBrewer)
output <- read.table("../data/tcga-clinical-information.txt", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
# Load classification by mutation profile (cluster assignment)
cluster.membership <- read.table("../data/annotation-matrix.txt", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
cluster.membership <- cluster.membership[,c(1:4)] # select columns
#rename some columns
colnames(cluster.membership)[colnames(cluster.membership)=="type"] <- "tissue"
colnames(cluster.membership)[colnames(cluster.membership)=="cluster"] <- "group"
# Change group from 1:22 to A:V
cluster.membership$group <- as.factor(cluster.membership$group)
levels(cluster.membership$group) <- LETTERS[1:length(unique(cluster.membership$group))]
# Merge clinical data with clustering
clinical <- merge(output,cluster.membership, by="id", sort=FALSE)
table(clinical$group)
table(clinical$group)
clinical[,c('age','event','time')] <- lapply(clinical[,c('age','event','time')], as.numeric)
# Remove subtype from tissue
clinical[,c('stage','group','tissue')] <- lapply(clinical[,c('stage','group','tissue')], factor)
# Kaplan-Meier curve for 22 groups
# Colors A -- V
colourysdots<-c("#202020","#771122","#AA4455","#DD7788","#774411","#AA7744",
"#DDAA77","#777711","#AAAA44","#DDDD77","#117744","#44AA77",
"#88CCAA","#117777","#44AAAA","#77CCCC","#114477","#4477AA",
"#77AADD","#771155","#AA4488","#CC99BB")
rm(list = ls())
mut.matrix <- read.table("../data/binary-mutation-matrix.txt", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
###########################
# Hierarchical clustering
###########################
hamming <- function(X) {
D <- (1 - X) %*% t(X)
D + t(D)
}
h.dist <- hamming(data.matrix(mut.matrix))
dist <- as.dist(h.dist)
clusters <- hclust(dist)
clustermembership.hclust <- cutree(clusters, k = 22)
###########################
# NMF clustering (remove zero lines and assign to specific group for survival analysis)
###########################
library(NMF)
mat <- t(mut.matrix)
mat <- mat[,colSums(mat) > 0]
set.seed(1234)
result <- nmf(x = mat, rank=21)
nmf_clusters <- apply(coef(result), 2, which.max)
clustermembership.nmf <- nmf_clusters
###########################
# K-Means
###########################
set.seed(1234)
# Best of 240 iterations
result <- kmeans(x = mut.matrix, centers = 22, nstart = 240)
clustermembership.kmeans <- fitted(result, method = "classes")
###########################
# mclust
###########################
library(mclust)
install.packages("NMF") library(NMF)
library(NMF)
mat <- t(mut.matrix)
mat <- mat[,colSums(mat) > 0]
set.seed(1234)
result <- nmf(x = mat, rank=21)
nmf_clusters <- apply(coef(result), 2, which.max)
clustermembership.nmf <- nmf_clusters
install.packages("NMF")
library(NMF)
mat <- t(mut.matrix)
mat <- mat[,colSums(mat) > 0]
set.seed(1234)
result <- nmf(x = mat, rank=21)
nmf_clusters <- apply(coef(result), 2, which.max)
clustermembership.nmf <- nmf_clusters
clustermembership.hclust
clustermembership.kmeans
clustermembership.mclust
###########################
# mclust
###########################
library(mclust)
BIC <- mclustBIC(mut.matrix, G = 22)
result <- Mclust(mut.matrix, 22, x = BIC)
clustermembership.mclust <- summary(result, parameters = TRUE)$classification
###########################
# clean-up and save
###########################
rm(hamming, h.dist, dist, clusters, mat, result, nmf_clusters, BIC)
mat <- t(mut.matrix)
mat <- mat[,colSums(mat) > 0]
set.seed(1234)
result <- nmf(x = mat, rank=21)
result <- nmf(x = mat, rank=21)
NMF::nmf
###########################
# clean-up and save
###########################
# rm(hamming, h.dist, dist, clusters, mat, result, nmf_clusters, BIC)
rm(hamming, h.dist, dist, clusters, mat, result, BIC)
BIC
BIC
mat
other_clustering.Rdata
save.image("other_clustering.Rdata")
load("~/Documents/phd_main/projects/network-based-clustering/pancancer-clustering-master/code/other_clustering.Rdata")
load("~/Documents/phd_main/projects/network-based-clustering/pancancer-clustering-master/code/other_clustering.Rdata")
rm(hamming, h.dist, dist, clusters, mat, result, nmf_clusters, BIC)
rm
??rm
?rm
clustermembership.mclust
paste(round(LR, 1), "&", pvalue, sep = " ")
LR
clusterTest
LR
