# Check for numeric columns
numeric_cols <- sapply(mut_cov_data_filtered, is.numeric)
# Check for columns with more than two unique values (not binary)
non_binary_cols <- sapply(mut_cov_data_filtered[numeric_cols], function(x) length(unique(x)) > 2)
# Get the indices of continuous non-binary columns
continuous_cols <- which(numeric_cols & non_binary_cols)
# Convert continuous variables to categorical with 3 levels
for (col in continuous_cols) {
mut_cov_data_filtered[[col]] <- cut(mut_cov_data_filtered[[col]], breaks = 3, labels = c(0:2))
}
# Check for columns without at least one entry with value 1
no_one_cols <- apply(mut_cov_data_filtered, 2, function(x) !any(x == 1))
# Get the indices of columns without at least one entry with value 1
no_one_col_indices <- which(no_one_cols)
# Change the levels of these columns to be 0 and 1
for (col in no_one_col_indices) {
mut_cov_data_filtered[[col]] <- droplevels(mut_cov_data_filtered[[col]])
mut_cov_data_filtered[[col]] <- revalue(mut_cov_data_filtered[[col]], c("2"="1"))
}
# Check the converted data
head(mut_cov_data_filtered)
dim(mut_cov_data_filtered)
# Read the data
mut_cov_data <- read.table("../data/binary-blood-mutation-matrix.txt")
# check how many missing samples there are
colSums(is.na(mut_cov_data))
# delete cols that have many missing values
mut_cov_data$BM_Mono <- NULL
mut_cov_data$dysplasia <- NULL
# Filter out rows with any NA entries
mut_cov_data_filtered <- na.omit(mut_cov_data)
# Remove columns with only zeros
zero_cols <- apply(mut_cov_data_filtered, 2, function(x) all(x == 0))
mut_cov_data_filtered <- mut_cov_data_filtered[, !zero_cols]
# Select continuous variable columns
# Check for numeric columns
numeric_cols <- sapply(mut_cov_data_filtered, is.numeric)
# Check for columns with more than two unique values (not binary)
non_binary_cols <- sapply(mut_cov_data_filtered[numeric_cols], function(x) length(unique(x)) > 2)
# Get the indices of continuous non-binary columns
continuous_cols <- which(numeric_cols & non_binary_cols)
# Convert continuous variables to categorical with 3 levels
for (col in continuous_cols) {
mut_cov_data_filtered[[col]] <- cut(mut_cov_data_filtered[[col]], breaks = 3, labels = c(0:2))
}
# Check for columns without at least one entry with value 1
no_one_cols <- apply(mut_cov_data_filtered, 2, function(x) !any(x == 1))
# Get the indices of columns without at least one entry with value 1
no_one_col_indices <- which(no_one_cols)
# Change the levels of these columns to be 0 and 1
for (col in no_one_col_indices) {
mut_cov_data_filtered[[col]] <- droplevels(mut_cov_data_filtered[[col]])
mut_cov_data_filtered[[col]] <- revalue(mut_cov_data_filtered[[col]], c("2"="1"))
}
# Check the converted data
head(mut_cov_data_filtered)
dim(mut_cov_data_filtered)
# check how many missing samples there are
colSums(is.na(mut_cov_data))
rm(list=ls())
# Read the data
mut_cov_data <- read.table("../data/binary-blood-mutation-matrix.txt")
# check how many missing samples there are
colSums(is.na(mut_cov_data))
# delete cols that have many missing values
mut_cov_data$BM_Mono <- NULL
mut_cov_data$dysplasia <- NULL
mut_cov_data$BM_Blast <- NULL
# Filter out rows with any NA entries
mut_cov_data_filtered <- na.omit(mut_cov_data)
# Remove columns with only zeros
zero_cols <- apply(mut_cov_data_filtered, 2, function(x) all(x == 0))
mut_cov_data_filtered <- mut_cov_data_filtered[, !zero_cols]
# Select continuous variable columns
# Check for numeric columns
numeric_cols <- sapply(mut_cov_data_filtered, is.numeric)
# Check for columns with more than two unique values (not binary)
non_binary_cols <- sapply(mut_cov_data_filtered[numeric_cols], function(x) length(unique(x)) > 2)
# Get the indices of continuous non-binary columns
continuous_cols <- which(numeric_cols & non_binary_cols)
# Convert continuous variables to categorical with 3 levels
for (col in continuous_cols) {
mut_cov_data_filtered[[col]] <- cut(mut_cov_data_filtered[[col]], breaks = 3, labels = c(0:2))
}
# Check for columns without at least one entry with value 1
no_one_cols <- apply(mut_cov_data_filtered, 2, function(x) !any(x == 1))
# Get the indices of columns without at least one entry with value 1
no_one_col_indices <- which(no_one_cols)
# Change the levels of these columns to be 0 and 1
for (col in no_one_col_indices) {
mut_cov_data_filtered[[col]] <- droplevels(mut_cov_data_filtered[[col]])
mut_cov_data_filtered[[col]] <- revalue(mut_cov_data_filtered[[col]], c("2"="1"))
}
# Check the converted data
head(mut_cov_data_filtered)
dim(mut_cov_data_filtered)
# Read the data
mut_cov_data <- read.table("../data/binary-blood-mutation-matrix.txt")
# check how many missing samples there are
colSums(is.na(mut_cov_data))
# delete cols that have many missing values
mut_cov_data$BM_Mono <- NULL
mut_cov_data$dysplasia <- NULL
# mut_cov_data$BM_Blast <- NULL
# Filter out rows with any NA entries
mut_cov_data_filtered <- na.omit(mut_cov_data)
# Remove columns with only zeros
zero_cols <- apply(mut_cov_data_filtered, 2, function(x) all(x == 0))
mut_cov_data_filtered <- mut_cov_data_filtered[, !zero_cols]
# Select continuous variable columns
# Check for numeric columns
numeric_cols <- sapply(mut_cov_data_filtered, is.numeric)
# Check for columns with more than two unique values (not binary)
non_binary_cols <- sapply(mut_cov_data_filtered[numeric_cols], function(x) length(unique(x)) > 2)
# Get the indices of continuous non-binary columns
continuous_cols <- which(numeric_cols & non_binary_cols)
# Convert continuous variables to categorical with 3 levels
for (col in continuous_cols) {
mut_cov_data_filtered[[col]] <- cut(mut_cov_data_filtered[[col]], breaks = 3, labels = c(0:2))
}
# Check for columns without at least one entry with value 1
no_one_cols <- apply(mut_cov_data_filtered, 2, function(x) !any(x == 1))
# Get the indices of columns without at least one entry with value 1
no_one_col_indices <- which(no_one_cols)
# Change the levels of these columns to be 0 and 1
for (col in no_one_col_indices) {
mut_cov_data_filtered[[col]] <- droplevels(mut_cov_data_filtered[[col]])
mut_cov_data_filtered[[col]] <- revalue(mut_cov_data_filtered[[col]], c("2"="1"))
}
# Check the converted data
head(mut_cov_data_filtered)
dim(mut_cov_data_filtered)
rm(list=ls())
# Read the data
mut_cov_data <- read.table("../data/binary-blood-mutation-matrix.txt")
# check how many missing samples there are
colSums(is.na(mut_cov_data))
# delete cols that have many missing values
mut_cov_data$BM_Mono <- NULL
mut_cov_data$dysplasia <- NULL
# mut_cov_data$BM_Blast <- NULL
# Filter out rows with any NA entries
mut_cov_data_filtered <- na.omit(mut_cov_data)
# Remove columns with only zeros
zero_cols <- apply(mut_cov_data_filtered, 2, function(x) all(x == 0))
mut_cov_data_filtered <- mut_cov_data_filtered[, !zero_cols]
# Select continuous variable columns
# Check for numeric columns
numeric_cols <- sapply(mut_cov_data_filtered, is.numeric)
# Check for columns with more than two unique values (not binary)
non_binary_cols <- sapply(mut_cov_data_filtered[numeric_cols], function(x) length(unique(x)) > 2)
# Get the indices of continuous non-binary columns
continuous_cols <- which(numeric_cols & non_binary_cols)
# Convert continuous variables to categorical with 3 levels
for (col in continuous_cols) {
mut_cov_data_filtered[[col]] <- cut(mut_cov_data_filtered[[col]], breaks = 3, labels = c(0:2))
}
# Check for columns without at least one entry with value 1
no_one_cols <- apply(mut_cov_data_filtered, 2, function(x) !any(x == 1))
# Get the indices of columns without at least one entry with value 1
no_one_col_indices <- which(no_one_cols)
# Change the levels of these columns to be 0 and 1
for (col in no_one_col_indices) {
mut_cov_data_filtered[[col]] <- droplevels(mut_cov_data_filtered[[col]])
mut_cov_data_filtered[[col]] <- revalue(mut_cov_data_filtered[[col]], c("2"="1"))
}
# Check the converted data
head(mut_cov_data_filtered)
dim(mut_cov_data_filtered)
# Network-based clustering of mutational and covariate data
# library("devtools")
# install_github("cbg-ethz/graphClust_NeurIPS")
library(netClust)
mut_cov_data <- read.table("../data/categorical-blood-mutation-matrix.txt")
cluster_results <- get_clusters(mut_cov_data, k_clust = 3, quick = FALSE)
saveRDS(cluster_results, "../results/cluster_results.rds")
# Prepare session, load packages
rm(list=ls())
# setwd("~/Documents/GitHub/modelling/analysis/")
library(survival)
library(RColorBrewer)
# Load classification by mutation profile (cluster assignment) # CLUSTERS
cluster_res <- readRDS("../results/cluster_results.rds")
table(cluster_res$clustermembership)
mut_cov_data <- read.table("../data/categorical-blood-mutation-matrix.txt")
# import survival data
survdata <- read.table("../data/binary_covariate_data2.txt")
#select the 151 samples - was missing "SP2020.1087" because of manual curation
survdata <- survdata[survdata$sp %in% rownames(mut_cov_data),] # delete if not in mut_cov_data
survdata <- survdata[order(survdata$sp),]
rownames(survdata) <- survdata$sp
survdata[survdata$dead=="#VALUE!"] <- 0 #typo in originating Excel file: all "#VALUE!"in dead == no dead (0)
mut_cov_data <- mut_cov_data[order(rownames(mut_cov_data)),]
head(rownames(survdata))
head(rownames(mut_cov_data))
survdata$last_fu <- as.Date(survdata$last_fu, format = "%d.%m.%Y")
survdata$firstdiagnosis_date <- as.Date(survdata$firstdiagnosis_date, format = "%d.%m.%Y")
survdata$relapse_date <- as.Date(survdata$relapse_date, format = "%d.%m.%Y")
survdata$type <- as.factor(survdata$type)
# calculate time to last follow-up
survdata$time <- as.numeric(difftime(survdata$last_fu, survdata$firstdiagnosis_date, units="days"))
# calculate time to last follow-up
survdata$time_remission <- as.numeric(difftime(survdata$relapse_date, survdata$firstdiagnosis_date, units="days"))
# merge clinical information and cluster membership
clinical <- list()
clinical$event <- survdata$dead
clinical$event_relapse <- survdata$relapse
clinical$time <- survdata$time
clinical$group <- cluster_res$clustermembership
# THESE NOW MATCH
length(clinical$group)
length(clinical$time)
# Change group from 1:22 to A:V
clinical$group <- as.factor(clinical$group)
levels(clinical$group) <- LETTERS[1:length(unique(clinical$group))]
table(clinical$group)
nb.cols <- length(unique(cluster_res$clustermembership))
colourysdots <- brewer.pal(nb.cols, "Set1")
plot(survfit(Surv(time = as.numeric(time)/365, event = as.numeric(event)) ~ group, data = clinical), col=colourysdots, ylab='Survival probability', xlab='Survival (years)', mark.time = T)
legend(x = 12.9, y = 1.0, legend = paste(levels(clinical$group), sep=' '), pch = 15, col=colourysdots, cex=1, ncol = 2,title="Cluster", bg='white')
# perform cox regression to get p-value
groupTest <- summary(coxph(Surv(time, event) ~ group, data = clinical, na.action = "na.omit"))$logtest[1]
pvalue <- round(pchisq(q = groupTest, df = length(levels(clinical$group)) - 1, lower.tail = FALSE), 10)
print(pvalue)
present_entries <- !is.na(survdata$time_remission)
clinical$time_relapse <- clinical$time
clinical$time_relapse[present_entries] <- survdata$time_remission[present_entries]
plot(survfit(Surv(time = as.numeric(time_relapse)/365, event = as.numeric(event_relapse)) ~ group, data = clinical), main="Title",col=colourysdots, ylab='Survival probability', xlab='Survival (years)', mark.time = T)
legend(x = 12.9, y = 1.0, legend = paste(levels(clinical$group), sep=' '), pch = 15, col=colourysdots, cex=1, ncol = 2,title="Cluster", bg='white')
# perform cox regression to get p-value
groupTest <- summary(coxph(Surv(time_relapse, event_relapse) ~ group, data = clinical, na.action = "na.omit"))$logtest[1]
pvalue <- round(pchisq(q = groupTest, df = length(levels(clinical$group)) - 1, lower.tail = FALSE), 10)
print(pvalue)
rm(list=ls())
# Read the data
mut_cov_data <- read.table("../data/binary-blood-mutation-matrix.txt")
# check how many missing samples there are
colSums(is.na(mut_cov_data))
# delete cols that have many missing values
# mut_cov_data$BM_Mono <- NULL
# mut_cov_data$dysplasia <- NULL
# mut_cov_data$BM_Blast <- NULL
# Filter out rows with any NA entries
mut_cov_data_filtered <- na.omit(mut_cov_data)
# Remove columns with only zeros
zero_cols <- apply(mut_cov_data_filtered, 2, function(x) all(x == 0))
mut_cov_data_filtered <- mut_cov_data_filtered[, !zero_cols]
# Select continuous variable columns
# Check for numeric columns
numeric_cols <- sapply(mut_cov_data_filtered, is.numeric)
# Check for columns with more than two unique values (not binary)
non_binary_cols <- sapply(mut_cov_data_filtered[numeric_cols], function(x) length(unique(x)) > 2)
# Get the indices of continuous non-binary columns
continuous_cols <- which(numeric_cols & non_binary_cols)
# Convert continuous variables to categorical with 3 levels
for (col in continuous_cols) {
mut_cov_data_filtered[[col]] <- cut(mut_cov_data_filtered[[col]], breaks = 3, labels = c(0:2))
}
# Check for columns without at least one entry with value 1
no_one_cols <- apply(mut_cov_data_filtered, 2, function(x) !any(x == 1))
# Get the indices of columns without at least one entry with value 1
no_one_col_indices <- which(no_one_cols)
# Change the levels of these columns to be 0 and 1
for (col in no_one_col_indices) {
mut_cov_data_filtered[[col]] <- droplevels(mut_cov_data_filtered[[col]])
mut_cov_data_filtered[[col]] <- revalue(mut_cov_data_filtered[[col]], c("2"="1"))
}
# Check the converted data
head(mut_cov_data_filtered)
dim(mut_cov_data_filtered)
# Save the filtered data to a text file
write.table(mut_cov_data_filtered, "../data/categorical-blood-mutation-matrix.txt", sep = "\t", row.names = TRUE, quote = FALSE)
# Network-based clustering of mutational and covariate data
# library("devtools")
# install_github("cbg-ethz/graphClust_NeurIPS")
library(netClust)
mut_cov_data <- read.table("../data/categorical-blood-mutation-matrix.txt")
cluster_results <- get_clusters(mut_cov_data, k_clust = 3, quick = FALSE)
saveRDS(cluster_results, "../results/cluster_results.rds")
setwd("~/Documents/phd_main/packages/graphClust/R")
setwd("~/Documents/phd_main/packages/graphClust")
load()
load("graphClust")
load(graphClust)
load_all()
# Prepare session, load packages
rm(list=ls())
# setwd("~/Documents/GitHub/modelling/analysis/")
library(survival)
library(RColorBrewer)
# Load classification by mutation profile (cluster assignment) # CLUSTERS
cluster_res <- readRDS("../results/cluster_results.rds")
setwd("~/Documents/phd_main/projects/collaboration_marco/modelling/analysis")
# Prepare session, load packages
rm(list=ls())
# setwd("~/Documents/GitHub/modelling/analysis/")
library(survival)
library(RColorBrewer)
# Load classification by mutation profile (cluster assignment) # CLUSTERS
cluster_res <- readRDS("../results/cluster_results.rds")
table(cluster_res$clustermembership)
mut_cov_data <- read.table("../data/categorical-blood-mutation-matrix.txt")
# import survival data
survdata <- read.table("../data/binary_covariate_data2.txt")
#select the 151 samples - was missing "SP2020.1087" because of manual curation
survdata <- survdata[survdata$sp %in% rownames(mut_cov_data),] # delete if not in mut_cov_data
survdata <- survdata[order(survdata$sp),]
rownames(survdata) <- survdata$sp
survdata[survdata$dead=="#VALUE!"] <- 0 #typo in originating Excel file: all "#VALUE!"in dead == no dead (0)
mut_cov_data <- mut_cov_data[order(rownames(mut_cov_data)),]
head(rownames(survdata))
head(rownames(mut_cov_data))
survdata$last_fu <- as.Date(survdata$last_fu, format = "%d.%m.%Y")
survdata$firstdiagnosis_date <- as.Date(survdata$firstdiagnosis_date, format = "%d.%m.%Y")
survdata$relapse_date <- as.Date(survdata$relapse_date, format = "%d.%m.%Y")
survdata$type <- as.factor(survdata$type)
# calculate time to last follow-up
survdata$time <- as.numeric(difftime(survdata$last_fu, survdata$firstdiagnosis_date, units="days"))
# calculate time to last follow-up
survdata$time_remission <- as.numeric(difftime(survdata$relapse_date, survdata$firstdiagnosis_date, units="days"))
# merge clinical information and cluster membership
clinical <- list()
clinical$event <- survdata$dead
clinical$event_relapse <- survdata$relapse
clinical$time <- survdata$time
clinical$group <- cluster_res$clustermembership
# THESE NOW MATCH
length(clinical$group)
length(clinical$time)
# clinical$age <- #here needs to go the age of the patients#
# plot(survfit(Surv(time = as.numeric(time)/365, event = as.numeric(event)) ~ group, data = clinical), col=colourysdots, ylab='Survival probability', xlab='Survival (years)', cex.lab=1.75, cex.axis=1.5, mark.time = T, xlim=c(0,24))
# Change group from 1:22 to A:V
clinical$group <- as.factor(clinical$group)
levels(clinical$group) <- LETTERS[1:length(unique(clinical$group))]
table(clinical$group)
# Kaplan-Meier curve for groups
nb.cols <- length(unique(cluster_res$clustermembership))
colourysdots <- brewer.pal(nb.cols, "Set1")
plot(survfit(Surv(time = as.numeric(time)/365, event = as.numeric(event)) ~ group, data = clinical), col=colourysdots, ylab='Survival probability', xlab='Survival (years)', mark.time = T)
legend(x = 12.9, y = 1.0, legend = paste(levels(clinical$group), sep=' '), pch = 15, col=colourysdots, cex=1, ncol = 2,title="Cluster", bg='white')
# perform cox regression to get p-value
groupTest <- summary(coxph(Surv(time, event) ~ group, data = clinical, na.action = "na.omit"))$logtest[1]
pvalue <- round(pchisq(q = groupTest, df = length(levels(clinical$group)) - 1, lower.tail = FALSE), 10)
print(pvalue)
# Relapse prediction
present_entries <- !is.na(survdata$time_remission)
clinical$time_relapse <- clinical$time
clinical$time_relapse[present_entries] <- survdata$time_remission[present_entries]
# Kaplan-Meier curve for groups
plot(survfit(Surv(time = as.numeric(time_relapse)/365, event = as.numeric(event_relapse)) ~ group, data = clinical), main="Title",col=colourysdots, ylab='Survival probability', xlab='Survival (years)', mark.time = T)
legend(x = 12.9, y = 1.0, legend = paste(levels(clinical$group), sep=' '), pch = 15, col=colourysdots, cex=1, ncol = 2,title="Cluster", bg='white')
# perform cox regression to get p-value
groupTest <- summary(coxph(Surv(time_relapse, event_relapse) ~ group, data = clinical, na.action = "na.omit"))$logtest[1]
pvalue <- round(pchisq(q = groupTest, df = length(levels(clinical$group)) - 1, lower.tail = FALSE), 10)
print(pvalue)
mut_cov_data <- read.table("../data/categorical-blood-mutation-matrix.txt")
cluster_results <- get_clusters(mut_cov_data, k_clust = 4, quick = FALSE)
saveRDS(cluster_results, "../results/cluster_results.rds")
# Prepare session, load packages
rm(list=ls())
# setwd("~/Documents/GitHub/modelling/analysis/")
library(survival)
library(RColorBrewer)
# Network-based clustering of mutational and covariate data
# library("devtools")
# install_github("cbg-ethz/graphClust_NeurIPS")
library(netClust)
mut_cov_data <- read.table("../data/categorical-blood-mutation-matrix.txt")
cluster_results <- get_clusters(mut_cov_data, k_clust = 2, quick = FALSE)
saveRDS(cluster_results, "../results/cluster_results.rds")
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
BiocManager::install(c("Rgraphviz", "RBGL"))
library("devtools")
install_github("cbg-ethz/graphClust_NeurIPS")
library("devtools")
install_github("cbg-ethz/graphClust_NeurIPS",force = TRUE)
# Prepare session, load packages
rm(list=ls())
library("devtools")
install_github("cbg-ethz/graphClust_NeurIPS",force = TRUE)
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
BiocManager::install(c("Rgraphviz", "RBGL"))
library("devtools")
install_github("cbg-ethz/graphClust_NeurIPS")
set.seed(startseed)
set.seed91
# Network-based clustering of mutational and covariate data
# library("devtools")
# install_github("cbg-ethz/graphClust_NeurIPS")
library(netClust)
mut_cov_data <- read.table("../data/categorical-blood-mutation-matrix.txt")
cluster_results <- get_clusters(mut_cov_data, k_clust = 2, quick = TRUE)
saveRDS(cluster_results, "../results/cluster_results.rds")
traceback()
traceback()
cluster_results <- get_clusters(mut_cov_data, k_clust = 3, quick = TRUE)
rm(list=ls())
# Read the data
mut_cov_data <- read.table("../data/binary-blood-mutation-matrix.txt")
# check how many missing samples there are
colSums(is.na(mut_cov_data))
# delete cols that have many missing values
# mut_cov_data$BM_Mono <- NULL
# mut_cov_data$dysplasia <- NULL
# mut_cov_data$BM_Blast <- NULL
# Filter out rows with any NA entries
mut_cov_data_filtered <- na.omit(mut_cov_data)
# Remove columns with only zeros
zero_cols <- apply(mut_cov_data_filtered, 2, function(x) all(x == 0))
mut_cov_data_filtered <- mut_cov_data_filtered[, !zero_cols]
# Select continuous variable columns
# Check for numeric columns
numeric_cols <- sapply(mut_cov_data_filtered, is.numeric)
# Check for columns with more than two unique values (not binary)
non_binary_cols <- sapply(mut_cov_data_filtered[numeric_cols], function(x) length(unique(x)) > 2)
# Get the indices of continuous non-binary columns
continuous_cols <- which(numeric_cols & non_binary_cols)
# Convert continuous variables to categorical with 3 levels
for (col in continuous_cols) {
mut_cov_data_filtered[[col]] <- cut(mut_cov_data_filtered[[col]], breaks = 3, labels = c(0:2))
}
# Check for columns without at least one entry with value 1
no_one_cols <- apply(mut_cov_data_filtered, 2, function(x) !any(x == 1))
# Get the indices of columns without at least one entry with value 1
no_one_col_indices <- which(no_one_cols)
# Change the levels of these columns to be 0 and 1
for (col in no_one_col_indices) {
mut_cov_data_filtered[[col]] <- droplevels(mut_cov_data_filtered[[col]])
mut_cov_data_filtered[[col]] <- revalue(mut_cov_data_filtered[[col]], c("2"="1"))
}
# Check the converted data
head(mut_cov_data_filtered)
dim(mut_cov_data_filtered)
# Save the filtered data to a text file
write.table(mut_cov_data_filtered, "../data/categorical-blood-mutation-matrix.txt", sep = "\t", row.names = TRUE, quote = FALSE)
# setwd("~/Documents/GitHub/modelling/analysis/")
library(survival)
library(RColorBrewer)
# Load classification by mutation profile (cluster assignment) # CLUSTERS
cluster_res <- readRDS("../results/cluster_results.rds")
table(cluster_res$clustermembership)
mut_cov_data <- read.table("../data/categorical-blood-mutation-matrix.txt")
# import survival data
survdata <- read.table("../data/binary_covariate_data2.txt")
#select the 151 samples - was missing "SP2020.1087" because of manual curation
survdata <- survdata[survdata$sp %in% rownames(mut_cov_data),] # delete if not in mut_cov_data
survdata <- survdata[order(survdata$sp),]
rownames(survdata) <- survdata$sp
survdata[survdata$dead=="#VALUE!"] <- 0 #typo in originating Excel file: all "#VALUE!"in dead == no dead (0)
mut_cov_data <- mut_cov_data[order(rownames(mut_cov_data)),]
head(rownames(survdata))
head(rownames(mut_cov_data))
survdata$last_fu <- as.Date(survdata$last_fu, format = "%d.%m.%Y")
survdata$firstdiagnosis_date <- as.Date(survdata$firstdiagnosis_date, format = "%d.%m.%Y")
survdata$relapse_date <- as.Date(survdata$relapse_date, format = "%d.%m.%Y")
survdata$type <- as.factor(survdata$type)
# calculate time to last follow-up
survdata$time <- as.numeric(difftime(survdata$last_fu, survdata$firstdiagnosis_date, units="days"))
# calculate time to last follow-up
survdata$time_remission <- as.numeric(difftime(survdata$relapse_date, survdata$firstdiagnosis_date, units="days"))
# merge clinical information and cluster membership
clinical <- list()
clinical$event <- survdata$dead
clinical$event_relapse <- survdata$relapse
clinical$time <- survdata$time
clinical$group <- cluster_res$clustermembership
# THESE NOW MATCH
length(clinical$group)
length(clinical$time)
# Change group from 1:22 to A:V
clinical$group <- as.factor(clinical$group)
levels(clinical$group) <- LETTERS[1:length(unique(clinical$group))]
table(clinical$group)
nb.cols <- length(unique(cluster_res$clustermembership))
colourysdots <- brewer.pal(nb.cols, "Set1")
plot(survfit(Surv(time = as.numeric(time)/365, event = as.numeric(event)) ~ group, data = clinical), col=colourysdots, ylab='Survival probability', xlab='Survival (years)', mark.time = T)
legend(x = 12.9, y = 1.0, legend = paste(levels(clinical$group), sep=' '), pch = 15, col=colourysdots, cex=1, ncol = 2,title="Cluster", bg='white')
# perform cox regression to get p-value
groupTest <- summary(coxph(Surv(time, event) ~ group, data = clinical, na.action = "na.omit"))$logtest[1]
pvalue <- round(pchisq(q = groupTest, df = length(levels(clinical$group)) - 1, lower.tail = FALSE), 10)
print(pvalue)
present_entries <- !is.na(survdata$time_remission)
clinical$time_relapse <- clinical$time
clinical$time_relapse[present_entries] <- survdata$time_remission[present_entries]
plot(survfit(Surv(time = as.numeric(time_relapse)/365, event = as.numeric(event_relapse)) ~ group, data = clinical), main="Title",col=colourysdots, ylab='Survival probability', xlab='Survival (years)', mark.time = T)
legend(x = 12.9, y = 1.0, legend = paste(levels(clinical$group), sep=' '), pch = 15, col=colourysdots, cex=1, ncol = 2,title="Cluster", bg='white')
# perform cox regression to get p-value
groupTest <- summary(coxph(Surv(time_relapse, event_relapse) ~ group, data = clinical, na.action = "na.omit"))$logtest[1]
pvalue <- round(pchisq(q = groupTest, df = length(levels(clinical$group)) - 1, lower.tail = FALSE), 10)
print(pvalue)
# # make a barplot
# # make a barplot
#
# Network-based clustering of mutational and covariate data
# library("devtools")
# install_github("cbg-ethz/graphClust_NeurIPS")
library(netClust)
mut_cov_data <- read.table("../data/categorical-blood-mutation-matrix.txt")
cluster_results <- get_clusters(mut_cov_data, k_clust = 3, quick = TRUE)
saveRDS(cluster_results, "../results/cluster_results.rds")
remove.packages(graphClust)
remove.packages("graphClust")
library("devtools")
install_github("cbg-ethz/graphClust_NeurIPS")
setwd("/Users/frbayer/Documents/phd_main/packages/graphClust_NeurIPS/R")
setwd("/Users/frbayer/Documents/phd_main/packages/graphClust_NeurIPS")
devtools::check()
devtools::check()
setwd("/Users/frbayer/Documents/phd_main/packages/graphClust")
devtools::check()
devtools::check()
devtools::submit_cran()
