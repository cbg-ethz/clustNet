---
title: "graphClust"
output: rmarkdown::html_vignette
description: >
  Network-based clustering of binary data. Optional adjustment for covariates. 
vignette: >
  %\VignetteIndexEntry{graphClust}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(devtools)
load_all()
library(graphClust)
```


### Demonstration:
Simulate binary data and learn clusters subsequently.

```{r, eval = FALSE}
# Simulate binary data
k_clust <- 3
ss <- c(400, 500, 600) # samples in each cluster
simulation_data <- graphClust::sampleData(k_clust = k_clust, n_vars = 20, n_samples = ss)

sampled_data <- simulation_data$sampled_data

# Network-based clustering
cluster_res_t <- get_clusters(sampled_data, k_clust = k_clust)

# library(mclust)
# cluster_res_t <- get_clusters(sampled_data, k_clust = k_clust, categorical = TRUE)

# cluster_res_t <- get_clusters(sampled_data, k_clust = k_clust,
#                               newallrelativeprobabs = cluster_res_t$newallrelativeprobabs, categorical=FALSE)

library(mclust)
adjustedRandIndex(simulation_data$cluster_membership, cluster_res_t$clustermembership)

library(RColorBrewer)
library(ggplot2)
library(ggraph)
library(igraph)
library(ggpubr)

# plot with ggraph package
# brewer.pal(6, "Spectral")
# mycolor <- brewer.pal(6, "Spectral")
# mycolor <- c("#d7191c")
# grp <- c(rep("Mutations",38), rep("CG",8), rep("Blood Values",6), rep("Bone Marrow",5), rep("Causal Covariates",3))

igraph::graph_from_adjacency_matrix(adj_matrix, mode="directed")

my_graph <- igraph::graph_from_adjacency_matrix(aa$DAGs[1][[1]], mode="directed")

nice_DAG_plot(my_graph)

plot_clusters(aa)



nice_DAG_plot <- function(my_graph){
  
  # add labelling
  number_of_bar=length(my_graph)
  id = seq(1, length(my_graph))
  angle= 360 * (id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
  hjust <- ifelse(angle > 90 & angle<270, 1, 0)
  angle <- ifelse(angle > 90 & angle<270, angle+180, angle)
  name <- names(V(my_graph))
  # Type <- as.factor(grp)
  
  p1 <- ggraph(my_graph, layout="circle")+
  geom_edge_arc(arrow = arrow(length = unit(2.3, 'mm')), 
                start_cap = circle(2.3, 'mm'),
                end_cap = circle(2, 'mm'), 
                edge_colour="black", edge_alpha=0.6, edge_width=0.4, aes(circular=TRUE)) +
  geom_node_point(size=3.5, color="#fdae61", alpha=0.9) +
  geom_node_text(aes(label=paste("    ",name,"    "), 
                angle=angle, hjust=hjust), size=2.3, color="black") +
  theme_void() +
  # theme(
  #   # legend.position="none",
  #   plot.margin=unit(c(0,0,0,0), "null"),
  #   panel.spacing=unit(c(0,0,0,0), "null")
  # ) +
  expand_limits(x = c(-1.2, 1.2), y = c(-1.2, 1.2)) +
  coord_fixed()
  
  print(p1)
  return(p1)
}


# define useful function
plot_clusters <- function(german_clusters){
  # plot DAGs of each cluster
  p_list <- list()
  k_clust <- length(german_clusters$DAGs)
  for (ii in 1:k_clust){
    my_graph <- igraph::graph_from_adjacency_matrix(german_clusters$DAGs[ii][[1]], mode="directed")
    p_list[[ii]] <- nice_DAG_plot(my_graph)
  }
  ggarrange(plotlist=p_list, labels = paste("Cluster", LETTERS[1:k_clust]))#, ncol = 2, nrow = 2)
}



# # Bernoulli mixture models 
# test_res <- BBMMclusterEM(sampled_data, 0.5, 3, nIterations = 10, verbose=TRUE)
# adjustedRandIndex(simulation_data$cluster_membership, test_res$newclustermembership)
# 
# test_res <- BMMclusterEM(sampled_data, 0.5, 3, nIterations = 10, verbose=TRUE)
# adjustedRandIndex(simulation_data$cluster_membership, test_res$newclustermembership)


# cluster_res_t <- get_clusters(sampled_data, k_clust = k_clust, 
#                               newallrelativeprobabs = cluster_res_t$newallrelativeprobabs, categorical=TRUE)
# 
# adjustedRandIndex(simulation_data$cluster_membership, cluster_res_t$clustermembership)
# 
# adjustedRandIndex(simulation_data$cluster_membership, cluster_res_t$clustermembership)
# 
# 
# res_kmeans1 <- kmeans(sampled_data, k_clust)
# adjustedRandIndex(simulation_data$cluster_membership, res_kmeans1$cluster)
# 
# aa <- mclust::Mclust(sampled_data, k_clust)
# adjustedRandIndex(simulation_data$cluster_membership, aa$classification)
# 
# res_BBMM2 <- BBMMclusterEM(sampled_data, chi = 0.5, k_clust = 5, startseed = 1 * 100, nIterations = 10, verbose = TRUE)
# adjustedRandIndex(simulation_data$cluster_membership, res_BBMM2$newclustermembership)


# alternatives:
# cluster_res <- graphCluster(my_data, kclust = 3)
# cluster_res_test <- graphClustParallel(my_data, kclust = 3)
# cluster_res_p <- graphClusterParallel(my_data, kclust = 3)
```
